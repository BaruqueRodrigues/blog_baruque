{
  "hash": "9c7c4a079319f00741809ee8fa115ce6",
  "result": {
    "markdown": "---\ntitle: \"Rodando Multiplos Modelos - Tutorial\"\nauthor: \"Baruque Rodrigues\"\ndate: \"2024-06-16\"\ncategories: [tutorial, code, model]\nimage: \"image.jpg\"\n---\n\n\n## \n\n### Rodando Multiplos Modelos\n\nUm processo muito comum na prática de análise de dados é encontrar um modelo que melhor resolva o seu problema, onde temos uma relação que queremos entender, por exemplo o número de funcionários de um Posto de Saúde da Família afeta a mortalidade de uma faixa etária dos municípios. O processo as vezes acaba sendo a construção de multiplos modelos, e a verificação um a um dos coeficientes. Meu objetivo aqui é apresentar uma forma de fazer com que esse processo repetitivo e manual possa ser acelerado, de maneira que o tempo do analista possa ser concentrado no que realmente importa, na compreensão do modelo.\n\n#### DRY - Don't Repeat Yourself\n\nPara aqueles que já foram meus alunos, ou trabalharam comigo sabem que esse é o um acronimo que eu sempre repito, afinal o O conceito DRY (Don't Repeat Yourself) é um princípio fundamental na programação, pois enfatiza a redução da redundância.\n\nEm essência, DRY sugere que qualquer pedaço de código deve ter uma única e clara chamada. Em vez de duplicar código, o princípio DRY incentiva a reutilização de componentes existentes, melhorando a manutenção e a legibilidade do código.\n\nTrocando em míudos, tente programar fazendo com que cada chunk de código não seja repetida.\n\n#### Pré requisitos\n\nEsse tutorial vai assumir que você já entenda os conceitos de pivoteamento e de pipeamento de funções, caso você não domine esses conteúdos, recomendo que você visite o r4ds.\n\n#### Botando as mãos na massa\n\nVamos utilizar dados de painel do DATASUS, armazenados em um arquivo RDS. Nosso objetivo é:\n\nCalcular um modelo de regressão para cada uma das taxas de mortalidade, onde cada taxa será a nossa variável dependente (VD).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n\n```{.r .cell-code}\ndados_painel <- rio::import(\"dados/dados_painel.rds\")\n\nglimpse(dados_painel)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 81,525\nColumns: 22\n$ municipio              <chr> \"110001 Alta Floresta D'Oeste\", \"110001 Alta Fl…\n$ ano                    <chr> \"1998\", \"1999\", \"2000\", \"2001\", \"2002\", \"2003\",…\n$ pessoas_psf            <dbl> 0, 0, 0, 0, 0, 0, 5, 5140, 7531, 15105, 17608, …\n$ pop_menor_1            <dbl> 557, 543, 515, 522, 529, 535, 541, 556, 563, 55…\n$ pop_1a4                <dbl> 2664, 2601, 2353, 2387, 2415, 2444, 2473, 2540,…\n$ pop_15a59              <dbl> 14627, 14281, 15820, 16049, 16240, 16435, 16629…\n$ pop_maior_60           <dbl> 1157, 1130, 1486, 1508, 1526, 1544, 1561, 1603,…\n$ pop_mun_todos          <dbl> 25630, 25023, 26533, 26916, 27237, 27563, 27886…\n$ mort_menor_1           <dbl> 17, 36, 10, 12, 12, 7, 5, 12, 8, 4, 8, 4, 10, 6…\n$ mort_1a4               <dbl> 1, 3, 2, 0, 3, 3, 1, 1, 2, 0, 3, 2, 2, 1, 0, 0,…\n$ mort_15a59             <dbl> 33, 64, 30, 45, 46, 44, 26, 37, 33, 24, 50, 44,…\n$ mort_maior_60          <dbl> 37, 53, 50, 52, 45, 60, 51, 53, 75, 34, 75, 59,…\n$ mort_todos             <dbl> 90, 167, 97, 111, 107, 116, 84, 105, 119, 64, 1…\n$ tx_mort_menor_1        <dbl> 30.520646, 66.298343, 19.417476, 22.988506, 22.…\n$ tx_mort_menor_1a4      <dbl> 0.3753754, 1.1534025, 0.8499788, 0.0000000, 1.2…\n$ tx_mort_menor_15a59    <dbl> 225.6102, 448.1479, 189.6334, 280.3913, 283.251…\n$ tx_mort_menor_maior_60 <dbl> 3197.926, 4690.265, 3364.738, 3448.276, 2948.88…\n$ tx_mort_todos          <dbl> 351.1510, 667.3860, 365.5825, 412.3941, 392.848…\n$ tx_cobertura_psf       <dbl> 0.00000000, 0.00000000, 0.00000000, 0.00000000,…\n$ cod_uf                 <chr> \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\",…\n$ existe_psf             <dbl> 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,…\n$ sigla_uf               <chr> \"RO\", \"RO\", \"RO\", \"RO\", \"RO\", \"RO\", \"RO\", \"RO\",…\n```\n:::\n:::\n\n\nObserve aqui que temos variáveis que indicam taxas de mortalidade para diferentes grupos etários, já que a taxa de mortalidade é nossa variável dependente uma das soluções seria executar um modelo para cada uma delas.\n\nO problema dessa abordagem é que o número de modelos escalaria muito rápido. Se temos 5 taxas de mortalidade serão 5 modelos, se adicionamos 1 variável de controle a cada uma delas, seriam 10 modelos.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplm::plm(tx_mort_menor_1 ~ pessoas_psf,\n         data = dados_painel,\n         model = \"within\",\n         index = c(\"ano\", \"municipio\")) %>% \n  summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOneway (individual) effect Within Model\n\nCall:\nplm::plm(formula = tx_mort_menor_1 ~ pessoas_psf, data = dados_painel, \n    model = \"within\", index = c(\"ano\", \"municipio\"))\n\nUnbalanced Panel: n = 15, T = 5372-5427, N = 81218\n\nResiduals:\n    Min.  1st Qu.   Median  3rd Qu.     Max. \n-17.1364 -11.0568  -1.2128   6.6585 242.8223 \n\nCoefficients:\n              Estimate Std. Error t-value Pr(>|t|)\npessoas_psf 6.6285e-08 4.6189e-08  1.4351   0.1513\n\nTotal Sum of Squares:    13746000\nResidual Sum of Squares: 13746000\nR-Squared:      2.5361e-05\nAdj. R-Squared: -0.00015936\nF-statistic: 2.05942 on 1 and 81202 DF, p-value: 0.15127\n```\n:::\n:::\n\n\nJá uma outra solução é utilizando tópicos de programação funcional. Primeiro nós iremos mudar o formato dos dados, de maneira que existam 5 variáveis, `pessoas_psf`, que é nossa Variável Independente, `nomes_mortalidade` que contém os nomes das nossas variáveis dependentes e `values_mortalidade` que contém os valores dessas variáveis, e as variáveis `municipio`, e `ano`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndados_painel %>% \n  select(contains(\"tx_mor\"), pessoas_psf, municipio, ano) %>%\n  # Organizando os dados em formato longo, empilhando as variáveis de mortalidade\n  pivot_longer(\n    cols = c(tx_mort_menor_1:tx_mort_todos),\n    names_to = \"nomes_mortalidade\",\n    values_to = \"values_mortalidade\"\n  ) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 407,625 × 5\n   pessoas_psf municipio              ano   nomes_mortalidade values_mortalidade\n         <dbl> <chr>                  <chr> <chr>                          <dbl>\n 1           0 110001 Alta Floresta … 1998  tx_mort_menor_1               30.5  \n 2           0 110001 Alta Floresta … 1998  tx_mort_menor_1a4              0.375\n 3           0 110001 Alta Floresta … 1998  tx_mort_menor_15…            226.   \n 4           0 110001 Alta Floresta … 1998  tx_mort_menor_ma…           3198.   \n 5           0 110001 Alta Floresta … 1998  tx_mort_todos                351.   \n 6           0 110001 Alta Floresta … 1999  tx_mort_menor_1               66.3  \n 7           0 110001 Alta Floresta … 1999  tx_mort_menor_1a4              1.15 \n 8           0 110001 Alta Floresta … 1999  tx_mort_menor_15…            448.   \n 9           0 110001 Alta Floresta … 1999  tx_mort_menor_ma…           4690.   \n10           0 110001 Alta Floresta … 1999  tx_mort_todos                667.   \n# ℹ 407,615 more rows\n```\n:::\n:::\n\n\nAgora nós iremos transformar nossos dados em nested_data. Onde iremos criar um subconjunto de dados para cada uma das taxas de mortalidade. Observe que a coluna data contém um dataset com 2 colunas e 81 mil linhas, nesse dataset está contida a variável `pessoas_psf` e a variável `values_mortalidade` que contém o o número das taxas de mortalidade por faixa\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndados_painel %>% \n  # Organizando os dados em formato longo, empilhando as variáveis de mortalidade\n  pivot_longer(\n    cols = c(tx_mort_menor_1:tx_mort_todos),\n    names_to = \"nomes_mortalidade\",\n    values_to = \"values_mortalidade\"\n  ) %>% \n  nest(data = -nomes_mortalidade) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 2\n  nomes_mortalidade      data                  \n  <chr>                  <list>                \n1 tx_mort_menor_1        <tibble [81,525 × 18]>\n2 tx_mort_menor_1a4      <tibble [81,525 × 18]>\n3 tx_mort_menor_15a59    <tibble [81,525 × 18]>\n4 tx_mort_menor_maior_60 <tibble [81,525 × 18]>\n5 tx_mort_todos          <tibble [81,525 × 18]>\n```\n:::\n:::\n\n\nAgora podemos executar o nosso modelo, para tal iremos criar uma coluna no dataset chamada `modelo_plm`, que conterá um modelo para cada uma das nossas variáveis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndados_painel %>% \n  select(contains(\"tx_mor\"), pessoas_psf, ano, municipio) %>%\n  # Organizando os dados em formato longo, empilhando as variáveis de mortalidade\n  pivot_longer(\n    cols = c(tx_mort_menor_1:tx_mort_todos),\n    names_to = \"nomes_mortalidade\",\n    values_to = \"values_mortalidade\"\n  ) %>% \n  nest(data = -nomes_mortalidade) %>% \n   mutate(\n    # Executando o modelo para cada variável\n    modelo_plm = map(data, ~plm::plm(values_mortalidade ~ pessoas_psf,\n                                      data = .,\n                                      model = \"within\",\n                                      index = c(\"ano\", \"municipio\"))),\n    # Transformando o modelo em um formato tabular\n    modelo_plm = map(modelo_plm, broom::tidy)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 3\n  nomes_mortalidade      data                  modelo_plm      \n  <chr>                  <list>                <list>          \n1 tx_mort_menor_1        <tibble [81,525 × 4]> <tibble [1 × 5]>\n2 tx_mort_menor_1a4      <tibble [81,525 × 4]> <tibble [1 × 5]>\n3 tx_mort_menor_15a59    <tibble [81,525 × 4]> <tibble [1 × 5]>\n4 tx_mort_menor_maior_60 <tibble [81,525 × 4]> <tibble [1 × 5]>\n5 tx_mort_todos          <tibble [81,525 × 4]> <tibble [1 × 5]>\n```\n:::\n:::\n\n\nAgora só precisamos remover a coluna data, que não tem nenhum valor analítico, e desenlistar a variável `modelo_plm` para checarmos os modelo.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndados_painel %>% \n  select(contains(\"tx_mor\"), pessoas_psf, ano, municipio) %>%\n  # Organizando os dados em formato longo, empilhando as variáveis de mortalidade\n  pivot_longer(\n    cols = c(tx_mort_menor_1:tx_mort_todos),\n    names_to = \"nomes_mortalidade\",\n    values_to = \"values_mortalidade\"\n  ) %>% \n  nest(data = -nomes_mortalidade) %>% \n   mutate(\n    # Executando o modelo para cada variável\n    modelo_plm = map(data, ~plm::plm(values_mortalidade ~ pessoas_psf,\n                                      data = .,\n                                      model = \"within\",\n                                      index = c(\"ano\", \"municipio\"))),\n    # Transformando o modelo em um formato tabular\n    modelo_plm = map(modelo_plm, broom::tidy)\n  ) %>% \n  select(-data) %>% \n  unnest_wider(modelo_plm)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 6\n  nomes_mortalidade      term             estimate   std.error statistic p.value\n  <chr>                  <chr>               <dbl>       <dbl>     <dbl>   <dbl>\n1 tx_mort_menor_1        pessoas_psf 0.0000000663      4.62e-8      1.44 0.151  \n2 tx_mort_menor_1a4      pessoas_psf 0.00000000414     3.18e-9      1.30 0.193  \n3 tx_mort_menor_15a59    pessoas_psf 0.00000113        4.71e-7      2.40 0.0163 \n4 tx_mort_menor_maior_60 pessoas_psf 0.0000141         5.11e-6      2.75 0.00591\n5 tx_mort_todos          pessoas_psf 0.00000133        8.63e-7      1.54 0.124  \n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}